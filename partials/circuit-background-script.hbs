<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
      "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/"
    }
  }
</script>

<script type="module">
  import * as THREE from 'three';
  import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/examples/jsm/postprocessing/UnrealBloomPass.js';

  // --- CONFIGURATION ---
  const CONFIG = {
    ORANGE: 0xff8c00,
    RUNNER_COLOR: 0xffaa44,
    SPARK_COLOR: 0xffaa00, // ORANGE INTENSE
    BLOOM_STRENGTH: 0.85,
    BLOOM_RADIUS: 0.4,
    BLOOM_THRESHOLD: 0.15,
    GLOBAL_SPEED: 0.8,

    MIN_DIST_X: 40,
    MAX_LINES_PER_SIDE: 4,
    PARTICLE_COUNT: 700,
    
    // NOUVEAU: Espacement vertical des murs latéraux (800px = ~Moitié moins dense)
    SIDE_SPACING: 800
  };

  const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance", alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

  // --- MONTAGE DOM ---
  const container = document.getElementById('circuit-background');
  if (container) {
    while (container.firstChild) container.removeChild(container.firstChild);
    container.appendChild(renderer.domElement);
  } else {
    renderer.domElement.style.position = 'fixed';
    renderer.domElement.style.top = '0';
    renderer.domElement.style.left = '0';
    renderer.domElement.style.zIndex = '-1';
    document.body.appendChild(renderer.domElement);
  }

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);

  const camera = new THREE.OrthographicCamera(
    window.innerWidth / -2, window.innerWidth / 2,
    window.innerHeight / 2, window.innerHeight / -2,
    1, 2000
  );
  camera.position.z = 1000;

  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  composer.addPass(new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    CONFIG.BLOOM_STRENGTH, CONFIG.BLOOM_RADIUS, CONFIG.BLOOM_THRESHOLD
  ));

  // --- TEXTURES ---
  function createTexture(drawFn, w = 64, h = 64) {
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const ctx = c.getContext('2d');
    drawFn(ctx, w, h);
    return new THREE.CanvasTexture(c);
  }

  const bgTex = createTexture((ctx, w, h) => {
    ctx.fillStyle = '#000000'; ctx.fillRect(0, 0, w, h);
    const g = ctx.createRadialGradient(w / 2, h / 2, w * 0.6, w / 2, h / 2, w * 1.2);
    g.addColorStop(0, 'rgba(0,0,0,1)');
    g.addColorStop(1, 'rgba(40, 15, 0, 0.1)');
    ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
  }, 512, 512);

  // HALO ADOUCI (Bout des lignes)
  const haloTex = createTexture((ctx, w, h) => {
    const g = ctx.createRadialGradient(w / 2, h / 2, 0, w / 2, h / 2, w / 2);
    // Opacité max réduite à 0.6 (au lieu de 1.0) pour moins d'agressivité
    g.addColorStop(0, 'rgba(255, 140, 0, 0.6)'); 
    g.addColorStop(0.5, 'rgba(255, 140, 0, 0.2)');
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
  });

  const runnerTex = createTexture((ctx, w, h) => {
    const g = ctx.createLinearGradient(0, 0, 0, h);
    g.addColorStop(0, 'rgba(255, 170, 68, 0)');
    g.addColorStop(0.2, 'rgba(255, 170, 68, 0.6)');
    g.addColorStop(0.8, 'rgba(255, 170, 68, 0.6)');
    g.addColorStop(1, 'rgba(255, 170, 68, 0)');
    ctx.fillStyle = g;
    ctx.fillRect(w * 0.2, 0, w * 0.6, h);
  }, 16, 128);

  // SPARK ADOUCI
  const sparkTex = createTexture((ctx, w, h) => {
    const g = ctx.createRadialGradient(w / 2, h / 2, 0, w / 2, h / 2, w / 2);
    // Coeur moins intense (0.8 au lieu de 1) et un peu plus jaune/doux
    g.addColorStop(0, 'rgba(255, 200, 50, 0.8)'); 
    g.addColorStop(0.4, 'rgba(255, 140, 0, 0.4)'); 
    g.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = g; ctx.fillRect(0, 0, w, h);
  }, 32, 32);

  const symbolsTex = [
    createTexture((ctx, w, h) => { ctx.strokeStyle = '#ff8c00'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(w / 2, h / 2, w * 0.35, 0, Math.PI * 2); ctx.stroke(); }),
    createTexture((ctx, w, h) => { ctx.strokeStyle = '#ff8c00'; ctx.lineWidth = 2; ctx.strokeRect(w * 0.25, h * 0.25, w * 0.5, h * 0.5); }),
    createTexture((ctx, w, h) => { ctx.strokeStyle = '#ff8c00'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(w / 2, h * 0.2); ctx.lineTo(w * 0.8, h * 0.8); ctx.lineTo(w * 0.2, h * 0.8); ctx.closePath(); ctx.stroke(); })
  ];

  // --- DATA ---
  let width = window.innerWidth, height = window.innerHeight;
  let leftRailX = width * 0.32, rightRailX = width * 0.68;

  let circuits = [];
  let sideCircuits = [];
  let particles = [];

  const depthLayers = [
    { id: 0, depth: 0.3, opacity: 0.25, xZone: [0.01, 0.06] },
    { id: 1, depth: 0.5, opacity: 0.35, xZone: [0.06, 0.12] },
    { id: 2, depth: 0.75, opacity: 0.50, xZone: [0.12, 0.18] },
    { id: 3, depth: 1.0, opacity: 0.75, xZone: [0.18, 0.26] }
  ];

  function createSprite(tex, size, color, opacity) {
    const m = new THREE.SpriteMaterial({ map: tex, color: color, transparent: true, opacity: opacity, blending: THREE.AdditiveBlending });
    const s = new THREE.Sprite(m);
    s.scale.set(size, size, 1);
    return s;
  }

  // --- COLLISION ---
  function checkCollision(x, y, layerId, side) {
    const candidates = circuits.filter(c => c.layer.id === layerId && c.side === side);
    for (let c of candidates) {
      const cY = c.mesh.position.y;
      if (y > cY + c.bounds.top + 50 || y + 300 < cY) continue;
      for (let pt of c.path) {
        if (Math.abs(pt.x - x) < CONFIG.MIN_DIST_X) return true;
      }
    }
    return false;
  }

  // --- GENERATION FOND ---
  function createCircuitObject(spawnY, layer, side, isPreFill = false) {
    const zs = layer.xZone[0] * width, ze = layer.xZone[1] * width;
    let startX = null, path = null, bounds = null;
    let isLong = false;

    const longCount = circuits.filter(c => c.isLong && c.mesh.position.y > -height && c.mesh.position.y < height).length;
    const forceLong = longCount < 1;

    for (let attempt = 0; attempt < 30; attempt++) {
      let tx = side === 'left' ? zs + Math.random() * (ze - zs) : width - zs - Math.random() * (ze - zs);

      if (!checkCollision(tx, spawnY, layer.id, side)) {

        let tempPath = [{ x: tx, y: 0 }];
        let curX = tx, curY = 0;
        let validCollision = true;

        isLong = forceLong || (Math.random() > 0.4);
        const segs = isLong ? 5 + Math.floor(Math.random() * 5) : 3 + Math.floor(Math.random() * 2);

        for (let s = 0; s < segs; s++) {
          curY += (isLong ? 80 : 50) + Math.random() * (isLong ? 150 : 80) + (attempt * 2);
          tempPath.push({ x: curX, y: curY });

          if (s < segs - 1 && Math.random() > 0.15) {
            const dx = (20 + Math.random() * 50) * (Math.random() > 0.5 ? 1 : -1);
            let nx = curX + dx;
            if (side === 'left') nx = Math.max(zs + 5, Math.min(ze - 5, nx));
            else nx = Math.max(width - ze + 5, Math.min(width - zs - 5, nx));

            if (checkCollision(nx, spawnY + curY, layer.id, side)) {
              validCollision = false; break;
            }
            curY += Math.abs(nx - curX); curX = nx;
            tempPath.push({ x: curX, y: curY });
          }
        }

        if (validCollision) {
          curY += 40 + Math.random() * 60;
          tempPath.push({ x: curX, y: curY });

          let isUnique = true;
          for (let c of circuits) {
            if (Math.abs(c.bounds.top - curY) / c.bounds.top < 0.15) { isUnique = false; break; }
          }

          if (isUnique) {
            startX = tx; path = tempPath; bounds = { top: curY, bottom: 0 };
            break;
          }
        }
      }
    }

    if (!path) return null;

    let finalY = spawnY;
    if (!isPreFill && spawnY < -height / 2 + 100) {
      finalY = -height / 2 - bounds.top - 100;
    }

    const pts = path.map(p => new THREE.Vector3(p.x - width / 2, p.y, 0));
    const geo = new THREE.BufferGeometry().setFromPoints(pts);
    const mat = new THREE.LineBasicMaterial({ color: CONFIG.ORANGE, transparent: true, opacity: layer.opacity, blending: THREE.AdditiveBlending });
    const mesh = new THREE.Line(geo, mat);
    mesh.position.set(0, finalY, 0);

    const capSize = (10 + Math.random() * 6) * layer.depth;
    // Opacité réduite pour les boules aux bouts (x1.5 au lieu de x2)
    const sCap = createSprite(haloTex, capSize, CONFIG.ORANGE, layer.opacity * 1.5);
    const eCap = createSprite(haloTex, capSize, CONFIG.ORANGE, layer.opacity * 1.5);

    scene.add(mesh); scene.add(sCap); scene.add(eCap);

    // --- ANIMATIONS ---
    const runners = [];
    let rectSegmentIndex = -1;

    // 1. RECTANGLE
    const vSegs = [];
    for (let i = 1; i < path.length; i++) {
      if (Math.abs(path[i].x - path[i - 1].x) < 2 && Math.abs(path[i].y - path[i - 1].y) > 120) {
        vSegs.push({
          index: i - 1,
          x: path[i].x, ymin: path[i - 1].y, ymax: path[i].y, len: path[i].y - path[i - 1].y
        });
      }
    }
    if (vSegs.length > 0 && Math.random() > 0.3) {
      const s = vSegs[Math.floor(Math.random() * vSegs.length)];
      rectSegmentIndex = s.index;

      const rLen = 30 + Math.random() * 40;
      const rW = 3 * layer.depth;
      const rMesh = createSprite(runnerTex, 1, CONFIG.RUNNER_COLOR, 0.9);
      rMesh.scale.set(rW, rLen, 1);
      rMesh.position.set(0, -99999, 0); rMesh.visible = false;
      scene.add(rMesh);

      const safeAmp = Math.max(0, (s.len - rLen) / 2 - 25);

      runners.push({
        type: 'rect',
        seg: s, rect: rMesh,
        localCy: (s.ymin + s.ymax) / 2,
        amp: safeAmp,
        ph: Math.random() * 10,
        spd: 0.02 + Math.random() * 0.02
      });
    }

    // 2. SPARK (Exclusion)
    const availableSegments = [];
    for (let i = 0; i < path.length - 1; i++) {
      if (i !== rectSegmentIndex) {
        availableSegments.push(i);
      }
    }

    if (availableSegments.length > 0) {
      const segIdx = availableSegments[Math.floor(Math.random() * availableSegments.length)];
      const sp1 = path[segIdx];
      const sp2 = path[segIdx + 1];

      const sparkSize = 12 * layer.depth;
      const sparkMesh = createSprite(sparkTex, 1, CONFIG.SPARK_COLOR, 1.0);
      sparkMesh.scale.set(sparkSize, sparkSize, 1);
      sparkMesh.position.set(0, -99999, 0); sparkMesh.visible = false;
      scene.add(sparkMesh);

      runners.push({
        type: 'spark',
        rect: sparkMesh,
        p1: sp1,
        p2: sp2,
        t: Math.random(),
        spd: 0.02 + Math.random() * 0.03
      });
    }

    return { mesh, sCap, eCap, runners, path, layer, side, bounds, isLong, pulse: Math.random() * 10 };
  }

  function createSideCircuit(spawnY, side) {
    const sx = side === 'left' ? leftRailX : rightRailX;
    const dir = side === 'left' ? -1 : 1;
    let path = [{ x: 0, y: 0 }];
    let cx = 0, cy = 0;
    const segs = 2 + Math.floor(Math.random() * 2);
    for (let s = 0; s < segs; s++) {
      cx += (80 + Math.random() * 150) * dir; path.push({ x: cx, y: cy });
      if (s < segs - 1 && Math.random() > 0.4) {
        const diag = 30 + Math.random() * 50; cx += diag * dir; cy += diag * (Math.random() > 0.5 ? 1 : -1); path.push({ x: cx, y: cy });
      }
    }
    path.push({ x: side === 'left' ? -800 : width + 800, y: cy });
    const pts = new Float32Array(20 * 3);
    const geo = new THREE.BufferGeometry();
    geo.setAttribute('position', new THREE.BufferAttribute(pts, 3));
    geo.setDrawRange(0, path.length);
    const mat = new THREE.LineBasicMaterial({ color: CONFIG.ORANGE, transparent: true, opacity: 0.35, blending: THREE.AdditiveBlending });
    const mesh = new THREE.Line(geo, mat);
    mesh.position.set(0, spawnY, 0);
    scene.add(mesh);
    const sCap = createSprite(haloTex, 16, CONFIG.ORANGE, 0.7); scene.add(sCap); // Opacité réduite
    const eCap = createSprite(haloTex, 16, CONFIG.ORANGE, 0.5); scene.add(eCap); // Opacité réduite
    return { mesh, sCap, eCap, startX: sx, localPath: path, side };
  }

  function createParticle() {
    const depth = 0.3 + Math.random() * 0.7;
    const side = Math.random() > 0.5;
    const margin = width * 0.1;
    const x = side ? Math.random() * (leftRailX - margin) : rightRailX + margin + Math.random() * (width - rightRailX - margin);
    const tex = symbolsTex[Math.floor(Math.random() * symbolsTex.length)];
    const size = (16 + Math.random() * 24) * (0.6 + depth * 0.4);
    const mesh = createSprite(tex, size, CONFIG.ORANGE, 0);
    mesh.position.set(x - width / 2, (Math.random() * height * 3) - height * 1.5, Math.random() * 80);
    scene.add(mesh);
    return { mesh, depth, speedOffset: Math.random() * 0.2, rotSpeed: (Math.random() - 0.5) * 0.03, pulse: Math.random() * 10 };
  }

  function init() {
    width = window.innerWidth; height = window.innerHeight;
    leftRailX = width * 0.32; rightRailX = width * 0.68;
    renderer.setSize(width, height);
    composer.setSize(width, height);
    camera.left = width / -2; camera.right = width / 2;
    camera.top = height / 2; camera.bottom = height / -2;
    camera.updateProjectionMatrix();

    while (scene.children.length > 0) scene.remove(scene.children[0]);

    const bgG = new THREE.PlaneGeometry(width, height);
    const bgM = new THREE.MeshBasicMaterial({ map: bgTex, depthTest: false });
    const bgMesh = new THREE.Mesh(bgG, bgM);
    bgMesh.position.z = -900; scene.add(bgMesh);

    circuits = []; sideCircuits = []; particles = [];

    for (let i = 0; i < CONFIG.PARTICLE_COUNT; i++) particles.push(createParticle());

    depthLayers.forEach(layer => {
      let simY = -height;
      while (simY < height * 1.5) {
        if (Math.random() > 0.3) {
          const c = createCircuitObject(simY, layer, 'left', true);
          if (c) circuits.push(c);
        }
        if (Math.random() > 0.3) {
          const c = createCircuitObject(simY + 50, layer, 'right', true);
          if (c) circuits.push(c);
        }
        simY += 150;
      }
    });

    let sideY = -height;
    while (sideY < height * 1.5) {
      if (Math.random() > 0.4) sideCircuits.push(createSideCircuit(sideY, 'left'));
      if (Math.random() > 0.4) sideCircuits.push(createSideCircuit(sideY + 150, 'right'));
      
      // ESPACEMENT AUGMENTÉ POUR RÉDUIRE LE NOMBRE DE LIGNES (800 au lieu de 300)
      sideY += CONFIG.SIDE_SPACING;
    }

    const loader = document.getElementById('loading');
    if (loader) loader.style.display = 'none';
  }

  window.addEventListener('resize', init);
  init();

  function animate() {
    requestAnimationFrame(animate);
    const speed = CONFIG.GLOBAL_SPEED;

    for (let i = circuits.length - 1; i >= 0; i--) {
      const c = circuits[i];
      c.mesh.position.y += speed;

      if (c.mesh.position.y > height / 2 + 200) {
        scene.remove(c.mesh); scene.remove(c.sCap); scene.remove(c.eCap);
        if (c.runners) c.runners.forEach(r => scene.remove(r.rect));
        circuits.splice(i, 1);
        continue;
      }

      c.pulse += 0.05;
      const p = 1 + Math.sin(c.pulse) * 0.2;
      c.sCap.position.set(c.path[0].x - width / 2, c.mesh.position.y + c.path[0].y, 1);
      c.sCap.scale.setScalar(c.sCap.scale.x * 0.9 + ((10 * c.layer.depth) * p) * 0.1);
      const endPt = c.path[c.path.length - 1];
      c.eCap.position.set(endPt.x - width / 2, c.mesh.position.y + endPt.y, 1);

      if (c.runners) {
        c.runners.forEach(runner => {
          if (runner.type === 'rect') {
            runner.ph += runner.spd;
            const osc = Math.sin(runner.ph) * runner.amp;
            const localY = runner.localCy + osc;
            runner.rect.position.set(runner.seg.x - width / 2, c.mesh.position.y + localY, 2);
            if (!runner.rect.visible) runner.rect.visible = true;
          }
          else if (runner.type === 'spark') {
            runner.t += runner.spd;
            const sineNorm = (Math.sin(runner.t) + 1) / 2;
            const progress = 0.15 + sineNorm * 0.70;
            const lx = runner.p1.x + (runner.p2.x - runner.p1.x) * progress;
            const ly = runner.p1.y + (runner.p2.y - runner.p1.y) * progress;
            runner.rect.position.set(lx - width / 2, c.mesh.position.y + ly, 3);
            if (!runner.rect.visible) runner.rect.visible = true;
          }
        });
      }
    }

    depthLayers.forEach(layer => {
      const cs = circuits.filter(c => c.layer.id === layer.id);
      const lefts = cs.filter(c => c.side === 'left');
      let lowestY = lefts.length > 0 ? Math.min(...lefts.map(c => c.mesh.position.y)) : height;

      if (lowestY > -height / 2) {
        if (lefts.length < CONFIG.MAX_LINES_PER_SIDE) {
          const c = createCircuitObject(-height / 2 - 200, layer, 'left', false);
          if (c) circuits.push(c);
        }
      }

      const rights = cs.filter(c => c.side === 'right');
      let lowestYR = rights.length > 0 ? Math.min(...rights.map(c => c.mesh.position.y)) : height;
      if (lowestYR > -height / 2) {
        if (rights.length < CONFIG.MAX_LINES_PER_SIDE) {
          const c = createCircuitObject(-height / 2 - 200, layer, 'right', false);
          if (c) circuits.push(c);
        }
      }
    });

    for (let i = sideCircuits.length - 1; i >= 0; i--) {
      const c = sideCircuits[i];
      c.mesh.position.y += speed;
      if (c.mesh.position.y > height / 2 + 200) {
        const minSideY = Math.min(...sideCircuits.map(s => s.mesh.position.y));
        // LOOP AVEC ESPACEMENT AUGMENTÉ
        const targetY = (minSideY < -height) ? minSideY - CONFIG.SIDE_SPACING : -height / 2 - 300;
        c.mesh.position.y = targetY;
      }
      const currentY = c.mesh.position.y;
      const pFactor = (currentY / (height * 0.5)) * 0.4;
      const pos = c.mesh.geometry.attributes.position.array;
      let idx = 0, lx = 0, ly = 0;
      for (let k = 0; k < c.localPath.length; k++) {
        const pt = c.localPath[k];
        const warpY = pt.y + (Math.abs(pt.x) * pFactor);
        pos[idx++] = (c.startX + pt.x) - width / 2;
        pos[idx++] = warpY;
        pos[idx++] = 0;
        if (Math.abs(pt.x) < 600) { lx = (c.startX + pt.x) - width / 2; ly = currentY + warpY; }
      }
      c.mesh.geometry.attributes.position.needsUpdate = true;
      c.sCap.position.set(c.startX - width / 2, currentY, 1);
      c.eCap.position.set(lx, ly, 1);
    }

    particles.forEach(p => {
      p.mesh.position.y += speed + p.speedOffset;
      if (p.mesh.position.y > height / 2 + 200) {
        p.mesh.position.y = -height / 2 - 400;
        const side = Math.random() > 0.5;
        const margin = width * 0.1;
        const nx = side ? Math.random() * (leftRailX - margin) : rightRailX + margin + Math.random() * (width - rightRailX - margin);
        p.mesh.position.x = nx - width / 2;
        p.speedOffset = Math.random() * 0.2;
      }
      p.pulse += 0.02;
      p.mesh.material.opacity = (0.5 + Math.sin(p.pulse) * 0.5) * 0.5 * p.depth;
      p.mesh.material.rotation += p.rotSpeed;
    });

    composer.render();
  }

  animate();
</script>