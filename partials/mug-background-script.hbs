<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
  import * as THREE from 'three';
  import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
  import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
  import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
  import { Reflector } from 'three/addons/objects/Reflector.js';

  // --- CONFIGURATION ---
  const CONFIG = {
    COLOR_MAIN: 0xff8c00,
    COLOR_GLOW: 0xffaa00,    
    BG_COLOR: 0x050508,      
    
    BLOOM_STRENGTH: 1.5,     
    BLOOM_RADIUS: 0.4,       
    BLOOM_THRESHOLD: 0,
    
    MUG_RADIUS: 4,
    MUG_HEIGHT: 10,
    COFFEE_LEVEL_OFFSET: 3.5, 
    TILT_ANGLE: Math.PI / 14,
  };

  // Logarithmic Depth Buffer activé pour la précision maximale
  const renderer = new THREE.WebGLRenderer({ 
      antialias: true, 
      powerPreference: "high-performance", 
      alpha: true,
      logarithmicDepthBuffer: true 
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio); 

  const container = document.getElementById('mug-background');
  if (container) {
    while (container.firstChild) container.removeChild(container.firstChild);
    container.appendChild(renderer.domElement);
  } else {
    renderer.domElement.style.position = 'fixed';
    renderer.domElement.style.top = '0';
    renderer.domElement.style.left = '0';
    renderer.domElement.style.zIndex = '-1';
    document.body.appendChild(renderer.domElement);
  }

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(CONFIG.BG_COLOR);
  scene.fog = new THREE.Fog(CONFIG.BG_COLOR, 15, 60);

  const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 14, 25); 
  camera.lookAt(0, 5, 0);

  const composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));

  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    CONFIG.BLOOM_STRENGTH,
    CONFIG.BLOOM_RADIUS,
    CONFIG.BLOOM_THRESHOLD
  );
  composer.addPass(bloomPass);

  // --- LUMIÈRES ---
  scene.add(new THREE.AmbientLight(0xffffff, 0.5)); 

  const spotLight = new THREE.SpotLight(0xffaa00, 10); 
  spotLight.position.set(0, 20, 5); 
  spotLight.angle = Math.PI / 4;
  spotLight.penumbra = 0.5;
  spotLight.decay = 1;
  spotLight.distance = 100;
  spotLight.target.position.set(0, 0, 0); 
  scene.add(spotLight);
  scene.add(spotLight.target);

  const bulbGeo = new THREE.SphereGeometry(0.5, 16, 16);
  const bulbMat = new THREE.MeshBasicMaterial({ color: 0xffcc88, toneMapped: false });
  const bulbMesh = new THREE.Mesh(bulbGeo, bulbMat);
  bulbMesh.position.copy(spotLight.position);
  scene.add(bulbMesh);


  // --- MATERIAUX ---
  
  const lineMaterial = new THREE.LineBasicMaterial({
    color: CONFIG.COLOR_MAIN,
    transparent: true,
    opacity: 0.8, 
    blending: THREE.AdditiveBlending
  });

  // --- SURFACE MUG CORRIGÉE (Ultra Transparente) ---
  const surfaceMaterial = new THREE.MeshBasicMaterial({
    color: CONFIG.COLOR_MAIN,
    transparent: true,
    opacity: 0.02, // <--- RÉDUIT ICI (Était 0.08). C'est très subtil maintenant.
    side: THREE.DoubleSide, 
    blending: THREE.AdditiveBlending, // Garde l'aspect lumineux
    depthWrite: false // Empêche le clignotement
  });

  // --- SOL INFINI ---
  const mirrorGeo = new THREE.PlaneGeometry(2000, 2000); 
  const groundMirror = new Reflector(mirrorGeo, {
    clipBias: 0.003, 
    textureWidth: window.innerWidth * window.devicePixelRatio,
    textureHeight: window.innerHeight * window.devicePixelRatio,
    color: 0x444444, 
    multisample: 4, 
  });
  groundMirror.position.y = -0.1; 
  groundMirror.rotateX(-Math.PI / 2);
  scene.add(groundMirror);

  const overlayGeo = new THREE.PlaneGeometry(2000, 2000);
  overlayGeo.rotateX(-Math.PI / 2);
  const overlayMat = new THREE.MeshBasicMaterial({
      color: CONFIG.BG_COLOR,
      transparent: true,
      opacity: 0.6, 
      side: THREE.DoubleSide,
      depthWrite: false
  });
  const overlay = new THREE.Mesh(overlayGeo, overlayMat);
  overlay.position.y = -0.05; 
  scene.add(overlay);

  const gridSize = 150; 
  const gridDivisions = 60; 
  const gridColor = 0x552200; 
  const gridHelper = new THREE.GridHelper(gridSize, gridDivisions, gridColor, gridColor); 
  gridHelper.position.y = 0.01; 
  gridHelper.material.transparent = true;
  gridHelper.material.opacity = 0.3; 
  gridHelper.material.depthWrite = false; 
  gridHelper.material.blending = THREE.AdditiveBlending;
  scene.add(gridHelper);

  // --- TEXTURES ---
  function createShapeTexture(type) {
    const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    const w = 128, h = 128;
    ctx.lineWidth = 6;
    ctx.strokeStyle = '#ffaa44'; 
    ctx.fillStyle = 'rgba(255, 170, 68, 0.1)'; 
    if (type === 'circle') {
      ctx.beginPath(); ctx.arc(w/2, h/2, w*0.35, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    } else if (type === 'triangle') {
      ctx.beginPath(); ctx.moveTo(w/2, h*0.2); ctx.lineTo(w*0.8, h*0.8); ctx.lineTo(w*0.2, h*0.8); ctx.closePath(); ctx.fill(); ctx.stroke();
    }
    return new THREE.CanvasTexture(canvas);
  }
  const circleTex = createShapeTexture('circle');
  const triangleTex = createShapeTexture('triangle');

  // --- MUG ---
  function createMugWireframe() {
    const group = new THREE.Group();
    const circleResolution = 128; 
    const verticalStruts = 24;

    function createRing(yPos, radius) {
      const points = [];
      for (let i = 0; i <= circleResolution; i++) {
        const theta = (i / circleResolution) * Math.PI * 2;
        points.push(new THREE.Vector3(Math.cos(theta) * radius, yPos, Math.sin(theta) * radius));
      }
      return new THREE.Line(new THREE.BufferGeometry().setFromPoints(points), lineMaterial);
    }

    group.add(createRing(CONFIG.MUG_HEIGHT / 2, CONFIG.MUG_RADIUS));
    group.add(createRing(-CONFIG.MUG_HEIGHT / 2, CONFIG.MUG_RADIUS));

    const bottomCenter = new THREE.Vector3(0, -CONFIG.MUG_HEIGHT / 2, 0);
    const spokePoints = [];
    for (let i = 0; i < verticalStruts; i++) {
      const theta = (i / verticalStruts) * Math.PI * 2;
      const x = Math.cos(theta) * CONFIG.MUG_RADIUS;
      const z = Math.sin(theta) * CONFIG.MUG_RADIUS;
      spokePoints.push(bottomCenter.clone());
      spokePoints.push(new THREE.Vector3(x, -CONFIG.MUG_HEIGHT / 2, z));
    }
    group.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(spokePoints), lineMaterial));

    const strutPoints = [];
    for (let i = 0; i < verticalStruts; i++) {
      const theta = (i / verticalStruts) * Math.PI * 2;
      const x = Math.cos(theta) * CONFIG.MUG_RADIUS;
      const z = Math.sin(theta) * CONFIG.MUG_RADIUS;
      strutPoints.push(new THREE.Vector3(x, -CONFIG.MUG_HEIGHT / 2, z));
      strutPoints.push(new THREE.Vector3(x, CONFIG.MUG_HEIGHT / 2, z));
    }
    group.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(strutPoints), lineMaterial));

    const curve = new THREE.CubicBezierCurve3(
      new THREE.Vector3(CONFIG.MUG_RADIUS, 2, 0),
      new THREE.Vector3(CONFIG.MUG_RADIUS + 3.5, 3.5, 0),
      new THREE.Vector3(CONFIG.MUG_RADIUS + 3.5, -3.5, 0),
      new THREE.Vector3(CONFIG.MUG_RADIUS, -2, 0)
    );
    const tubeGeo = new THREE.TubeGeometry(curve, 24, 0.6, 6, false);
    group.add(new THREE.LineSegments(new THREE.EdgesGeometry(tubeGeo), lineMaterial));

    // CORPS UNIQUE (Holographique)
    const bodyGeo = new THREE.CylinderGeometry(CONFIG.MUG_RADIUS, CONFIG.MUG_RADIUS, CONFIG.MUG_HEIGHT, 64, 1, true);
    const bodyMesh = new THREE.Mesh(bodyGeo, surfaceMaterial);
    bodyMesh.scale.set(0.995, 0.995, 0.995); 
    // RenderOrder 2 pour qu'il soit dessiné APRES le liquide
    bodyMesh.renderOrder = 2; 
    group.add(bodyMesh);
    
    return group;
  }

  // --- LIQUIDE ET FUMÉE ---
  let bubbles = []; 
  let steamParticles = [];
  let bubbleGroup;

  function createLiquid() {
    const group = new THREE.Group();
    bubbleGroup = group; 
    
    const liquidGeo = new THREE.CylinderGeometry(CONFIG.MUG_RADIUS - 0.1, CONFIG.MUG_RADIUS - 0.1, 0.1, 64);
    
    // Matériau ENCRE NOIRE (Opaque)
    const liquidMat = new THREE.MeshPhongMaterial({
      color: 0x1a0a05,            
      emissive: 0x000000,         
      specular: 0x331100, 
      shininess: 60,              
      transparent: false, // Opaque
    });
    
    const liquidMesh = new THREE.Mesh(liquidGeo, liquidMat);
    // RenderOrder 1 : Dessiné avant le verre du mug
    liquidMesh.renderOrder = 1; 
    group.add(liquidMesh);

    const pts = [];
    for(let i=0; i<=128; i++) {
      const t = (i/128)*Math.PI*2;
      pts.push(new THREE.Vector3(Math.cos(t)*(CONFIG.MUG_RADIUS-0.1), 0.06, Math.sin(t)*(CONFIG.MUG_RADIUS-0.1)));
    }
    group.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts), new THREE.LineBasicMaterial({
      color: 0xffaa44, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
    })));

    const steamCount = 30; 
    const steamMat = new THREE.SpriteMaterial({ map: circleTex, color: 0xffaa44, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending, depthWrite: false });
    const steamMatTri = new THREE.SpriteMaterial({ map: triangleTex, color: 0xff8c00, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending, depthWrite: false });

    for(let i=0; i<steamCount; i++) {
      const isTri = Math.random() > 0.5;
      const sprite = new THREE.Sprite(isTri ? steamMatTri : steamMat);
      resetSteamParticleLocal(sprite);
      sprite.position.y = Math.random() * 8; 
      group.add(sprite);
      steamParticles.push({ sprite: sprite, speed: 0.02 + Math.random() * 0.03, wobbleSpeed: Math.random() * 2, wobbleAmp: 0.01 + Math.random() * 0.02 });
    }
    return { group }; 
  }

  function resetSteamParticleLocal(sprite) {
    const r = Math.random() * (CONFIG.MUG_RADIUS - 1.5);
    const ang = Math.random() * Math.PI * 2;
    sprite.position.x = Math.cos(ang) * r;
    sprite.position.z = Math.sin(ang) * r;
    sprite.position.y = 0.2; 
    sprite.scale.setScalar(0.2 + Math.random() * 0.3);
  }

  // --- HIÉRARCHIE ---
  const precessionGroup = new THREE.Group();
  scene.add(precessionGroup);
  
  const tiltGroup = new THREE.Group();
  precessionGroup.add(tiltGroup);
  
  const counterSpinGroup = new THREE.Group();
  tiltGroup.add(counterSpinGroup);
  
  const mugObj = createMugWireframe();
  counterSpinGroup.add(mugObj);
  
  const liquidObj = createLiquid();
  precessionGroup.add(liquidObj.group); 

  // --- PARTICULES FOND ---
  const particlesGeo = new THREE.BufferGeometry();
  const particleCount = 1000;
  const posArray = new Float32Array(particleCount * 3);
  const speeds = [];
  for(let i = 0; i < particleCount * 3; i+=3) {
    const angle = Math.random() * Math.PI * 2;
    const radius = 6 + Math.random() * 25;
    posArray[i] = Math.cos(angle) * radius;
    posArray[i+1] = (Math.random() - 0.5) * 40;
    posArray[i+2] = Math.sin(angle) * radius;
    speeds.push(0.01 + Math.random() * 0.03); 
  }
  particlesGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
  const particlesMesh = new THREE.Points(particlesGeo, new THREE.PointsMaterial({
    size: 0.12, color: CONFIG.COLOR_GLOW, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending
  }));
  scene.add(particlesMesh);

  // --- ANIMATION ---
  const clock = new THREE.Clock();
  const R = CONFIG.MUG_RADIUS;
  const H = CONFIG.MUG_HEIGHT;
  let accumulatedPrecession = 0;

  function spawnBubble() {
    const r = 0.1 + Math.random() * 0.3; 
    const bubbleGeo = new THREE.RingGeometry(r, r + 0.05, 32); 
    bubbleGeo.rotateX(-Math.PI / 2);
    const bubbleMesh = new THREE.Mesh(bubbleGeo, new THREE.MeshBasicMaterial({
        color: 0xffcc88, transparent: true, opacity: 0, side: THREE.DoubleSide
    }));
    
    const dist = Math.random() * (CONFIG.MUG_RADIUS - 1.5);
    const ang = Math.random() * Math.PI * 2;
    
    bubbleMesh.position.set(Math.cos(ang)*dist, 0.08, Math.sin(ang)*dist);
    
    const bubble = {
        mesh: bubbleMesh,
        baseX: bubbleMesh.position.x,
        baseZ: bubbleMesh.position.z,
        life: 0, 
        lifeSpeed: 0.005 + Math.random() * 0.015, 
        maxScale: 1.0 + Math.random() * 0.5 
    };
    bubbleGroup.add(bubbleMesh);
    bubbles.push(bubble);
  }

  function animate() {
    requestAnimationFrame(animate);
    const time = clock.getElapsedTime();

    const camX = Math.sin(time * 0.3) * 7.0; 
    const camY = 14 + Math.cos(time * 0.25) * 4.0; 
    const camZ = 22 + Math.sin(time * 0.2) * 3.0;
    camera.position.set(camX, camY, camZ);
    const targetX = Math.sin(time * 0.15) * 2.0; 
    const targetY = 7 + Math.cos(time * 0.2) * 1.0; 
    camera.lookAt(targetX, targetY, 0);

    const wobble1 = Math.sin(time * 1.2);
    const wobble2 = Math.cos(time * 0.7);
    const wobble3 = Math.sin(time * 0.3);
    
    const randomTilt = CONFIG.TILT_ANGLE + (wobble1 * 0.02 + wobble2 * 0.015 + wobble3 * 0.01);
    const currentTilt = Math.max(0.05, Math.abs(randomTilt)); 
    const currentSpeed = 0.5 + (currentTilt * 2.0) + (wobble2 * 0.2); 
    
    accumulatedPrecession += currentSpeed * 0.016;
    
    precessionGroup.rotation.y = accumulatedPrecession;
    tiltGroup.rotation.x = currentTilt;
    counterSpinGroup.rotation.y = -accumulatedPrecession; 

    const contactY = (H/2) * Math.cos(currentTilt) + R * Math.sin(currentTilt);
    precessionGroup.position.y = contactY + 0.02; 
    
    const shiftZ = (H/2) * Math.sin(currentTilt) - R * Math.cos(currentTilt);
    tiltGroup.position.z = -shiftZ;

    const liquidY = CONFIG.COFFEE_LEVEL_OFFSET * Math.cos(currentTilt);
    const liquidZ = CONFIG.COFFEE_LEVEL_OFFSET * Math.sin(currentTilt) - shiftZ;
    liquidObj.group.position.set(0, liquidY, liquidZ);
    const cosTilt = Math.cos(currentTilt);
    const scaleZ = (Math.abs(cosTilt) > 0.001) ? 1 / cosTilt : 100;
    liquidObj.group.scale.set(1, 1, scaleZ);

    steamParticles.forEach(p => {
      p.sprite.position.y += p.speed; 
      p.sprite.position.x += Math.sin(time * p.wobbleSpeed + p.sprite.position.y) * p.wobbleAmp;
      const maxH = 12; 
      const normalizedH = p.sprite.position.y / maxH;
      let opacity = (normalizedH < 0.1) ? normalizedH * 10 * 0.2 : (1 - normalizedH) * 0.2;
      p.sprite.material.opacity = Math.max(0, opacity);
      p.sprite.scale.setScalar(0.2 + normalizedH * 0.3);
      if (p.sprite.position.y > maxH) resetSteamParticleLocal(p.sprite);
    });

    const targetBubbleCount = 3 + Math.floor(Math.random() * 4); 
    if (bubbles.length < targetBubbleCount && Math.random() < 0.05) spawnBubble();
    
    for (let i = bubbles.length - 1; i >= 0; i--) {
        const b = bubbles[i];
        b.life += b.lifeSpeed;
        let scale = 1, opacity = 0;
        if (b.life < 0.2) { opacity = b.life * 5 * 0.6; scale = 0.5 + b.life * 2.5; }
        else if (b.life < 0.8) { opacity = 0.6; scale = 1.0 + (b.life - 0.2) * 0.2; }
        else { opacity = (1 - b.life) * 5 * 0.6; scale = 1.12 + (b.life - 0.8) * 2; }
        b.mesh.material.opacity = opacity;
        b.mesh.scale.setScalar(scale * b.maxScale);
        b.mesh.position.y = 0.08 + Math.sin(b.baseX * 1.5 + time * 3) * 0.02; 
        if (b.life >= 1) { bubbleGroup.remove(b.mesh); bubbles.splice(i, 1); }
    }

    bloomPass.strength = CONFIG.BLOOM_STRENGTH;

    const pPos = particlesGeo.attributes.position.array;
    for(let i = 0; i < particleCount; i++) {
      const idx = i * 3;
      pPos[idx + 1] += speeds[i];
      if (pPos[idx + 1] > 20) pPos[idx + 1] = -20;
    }
    particlesGeo.attributes.position.needsUpdate = true;

    composer.render();
  }

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio); 
    composer.setSize(window.innerWidth, window.innerHeight);
    if(groundMirror.getRenderTarget) {
         groundMirror.getRenderTarget().setSize(
            window.innerWidth * window.devicePixelRatio, 
            window.innerHeight * window.devicePixelRatio
         );
    }
  });

  animate();
</script>